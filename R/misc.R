#' Cumulatively collapse along a vector
#'
#' @param x The character vector to collapse
#' @param collapse The character to use for collapsing
#'
#' @examples
#'
#' x <- c("","data","exon","i")
#' collapse_along(x)
#'
collapse_along <- function(x,
                           collapse = "/") {

  out <- vector(length = length(x))

   for(i in 1:length(x)) {
    out[i] <- paste(x[1:i], collapse = collapse)
  }

  out
}


#' Transpose a gene x sample data.frame without losing a gene_name or sample_name column
#'
#' @param df The data.frame to transpose
#' @param gene_col The column used for gene names. Default = "gene_name".
#' @param sample_col The column used for sample names. Default = "sample_name".
#'
flip_table <- function(df,
                       gene_col = "gene_name",
                       sample_col = "sample_name") {

  if(gene_col %in% names(df)) {
    genes <- unlist(df[,gene_col])
    df_t <- t(df[,names(df) != gene_col])
    samples <- rownames(df_t)
    df_out <- cbind(samples, as.data.frame(df_t))
    names(df_out) <- c(sample_col,genes)
    rownames(df_out) <- NULL

    df_out

  } else if(sample_col %in% names(df)) {

    samples <- unlist(df[,sample_col])
    df_t <- t(df[,names(df) != sample_col])
    genes <- rownames(df_t)
    df_out <- cbind(genes, as.data.frame(df_t))
    names(df_out) <- c(gene_col, samples)
    rownames(df_out) <- NULL

    df_out

  } else {
    print(paste("No column named",gene_col,"or",sample_col,"found."))
  }

}

#' Generate a rainbow palette with variation in saturation and value
#'
#' @param n_colors The number of colors to generate
#'
varibow <- function(n_colors) {
  sats <- rep_len(c(0.55,0.7,0.85,1),length.out = n_colors)
  vals <- rep_len(c(1,0.8,0.6),length.out = n_colors)
  sub("FF$","",grDevices::rainbow(n_colors, s = sats, v = vals))
}

#' Convert values to colors along a color ramp
#'
#' @param x a numeric vector to be converted to colors
#' @param min_val a number that's used to set the low end of the color scale (default = 0)
#' @param max_val a number that's used to set the high end of the color scale. If NULL (default),
#' use the highest value in x
#' @param colorset a set of colors to interpolate between using colorRampPalette
#' (default = c("darkblue","dodgerblue","gray80","orangered","red"))
#' @param missing_color a color to use for missing (NA) values.
#' @return a character vector of hex color values generated by colorRampPalette. Color values will
#' remain in the same order as x.
values_to_colors <- function(x,
                             min_val = NULL,
                             max_val = NULL,
                             colorset = c("darkblue","dodgerblue","gray80","orange","orangered"),
                             missing_color = "black") {

  heat_colors <- grDevices::colorRampPalette(colorset)(1001)

  if(is.null(max_val)) {
    max_val <- max(x, na.rm = T)
  } else {
    x[x > max_val] <- max_val
  }
  if (is.null(min_val)) {
    min_val <- min(x, na.rm = T)
  } else {
    x[x < min_val] <- min_val
  }

  if(sum(x == min_val, na.rm = TRUE) == length(x)) {
    colors <- rep(heat_colors[1],length(x))
  } else {
    if(length(x) > 1) {
      if(var(x, na.rm = TRUE) == 0) {
        colors <- rep(heat_colors[500], length(x))
      } else {
        heat_positions <- unlist(round((x - min_val) / (max_val - min_val) * 1000 + 1, 0))

        colors <- heat_colors[heat_positions]
      }
    } else {
      colors <- heat_colors[500]
    }
  }

  if(!is.null(missing_color)) {
    colors[is.na(colors)] <- grDevices::rgb(t(grDevices::col2rgb(missing_color)/255))
  }

  colors
}




#' Caculate default stats for sifter and then write to tome
#'
#' In this case, the target tome will need to have exon and intron data matrices, as well as annotations with the base "cluster".
#'
#' @param tome Path to the target tome file.1
#' @param overwrite Whether or not to overwrite existing annotations. Default is NULL, which will use the global settings defined with set_scrattch.io_global_overwrite().
#'
write_tome_sifter_stats <- function(tome,
                                    overwrite = NULL) {


  ## Read in the relevant data from tome
  genes     <- read_tome_gene_names(tome)
  samples   <- read_tome_sample_names(tome)
  anno      <- read_tome_anno(tome)
  exons     <- read_tome_dgCMatrix(tome, "data/t_exon")
  introns   <- read_tome_dgCMatrix(tome, "data/t_intron")
  countsIE  <- exons+introns
  log2cpmIE <- logCPM(countsIE)

  ## Labels for all clusters used in the statistics
  all_clusters <- unique(anno$cluster_id)
  all_clusters <- all_clusters[order(all_clusters)]
  allClust     <- paste0("cluster_",all_clusters)

  ## Generate the count statistics
  count_gt0 <- matrix(0, ncol = length(all_clusters), nrow = nrow(log2cpmIE))
  count_gt1 <- sums <- medianmat <- count_gt0

  for(i in 1:length(all_clusters)) {
    cluster         <- all_clusters[i]
    cluster_samples <- which(anno$cluster_id == cluster)
    cluster_data    <- log2cpmIE[,cluster_samples]
    cluster_counts  <- countsIE[,cluster_samples]
    count_gt0[,i]   <- Matrix::rowSums(cluster_counts > 0)
    count_gt1[,i]   <- Matrix::rowSums(cluster_counts > 1)
    sums[,i]        <- Matrix::rowSums(cluster_counts)
    medianmat[,i]   <- apply(cluster_data,1,median)
  }
  colnames(count_gt0) <- colnames(count_gt1) <- colnames(sums) <-
    colnames(medianmat) <- allClust

  count_gt0 <- cbind(gene = genes, as.data.frame(count_gt0))
  count_gt1 <- cbind(gene = genes, as.data.frame(count_gt1))
  sums      <- cbind(gene = genes, as.data.frame(sums))
  medianmat <- cbind(gene = genes, as.data.frame(medianmat))

  count_n <- anno %>%
    arrange(cluster_id) %>%
    group_by(cluster_id) %>%
    summarise(n_cells = n())

  ## Write the count statistics
  try(write_tome_stats(stats = count_gt0, stats_name = "count_gt0", tome = tome, overwrite = overwrite))
  try(write_tome_stats(stats = count_gt1, stats_name = "count_gt1", tome = tome, overwrite = overwrite))
  try(write_tome_stats(stats = count_n, stats_name = "count_n", tome = tome, overwrite = overwrite))
  try(write_tome_stats(stats = sums, stats_name = "sums", tome = tome, overwrite = overwrite))
  try(write_tome_stats(stats = medianmat, stats_name = "medians", tome = tome, overwrite = overwrite))


}



#' Expands a tome file to the expected feather and rda files for molgen-shiny
#'
#' This file takes a tome as input and writes all of the necessary files for molgen-shiny to work properly in a feather file
#'
#' @param tome Path to the target tome file.1
#' @param output_folder Folder where output files should be written (default is current directory)
#' @param regions Which gene regions to use. Can be "both" (default"), "exon", or "intron".
#' @param dend_name Name of dendrogram to read (default="cluster")
#' @param projection_name Name of projection to read (default="tsne"). Currently only compatible with a single projection map.
#'
#' @return No R objects returned.
#'
convert_tome_to_feather <- function(tome,
                                    output_folder = getwd(),
                                    regions = "both",
                                    dend_name = "cluster",
                                    projection_name = "tsne") {

  if(!grepl("/$",output_folder)) {
    output_folder <- paste0(output_folder,"/")  # Add a trailing / if needed
  }

  ## Read in genes, samples, annotations, descriptions, and dendrogram
  genes     <- read_tome_gene_names(tome)
  samples   <- read_tome_sample_names(tome)
  anno      <- read_tome_anno(tome)
  desc      <- read_tome_anno_desc(tome)
  dend      <- read_tome_dend(tome,dend_name)

  ## Update anno column names
  if(sum(is.element(names(anno),c("sample_name","sample_id")))==2)
    anno = anno[,colnames(anno)!="sample_name"]
  if(sum(names(anno) == "sample_id")==0)
    names(anno)[names(anno) == "sample_name"] <- "sample_id"
  # shiny uses sample_id instead of sample_name, but crashes if both are present
  anno <- anno[,match(unique(colnames(anno)),colnames(anno))]
  # remove duplicate column names

  ## Write out annotations, descriptions, and dendrogram
  print("Writing anno.feather")
  feather::write_feather(anno,paste0(output_folder,"anno.feather"))
  print("Writing desc.feather")
  feather::write_feather(desc,paste0(output_folder,"desc.feather"))
  print("Writing dend.RData")
  saveRDS(dend,paste0(output_folder,"dend.RData"))


  ## Read in, format, and write the main data files
  if(regions %in% c("both","exon")) {
    exons     <- read_tome_dgCMatrix(tome, "/data/exon")
  }

  if(regions %in% c("both","intron")) {
    if(check_tome_existence(tome, "/data/intron")) {
      introns   <- read_tome_dgCMatrix(tome, "/data/intron")
    } else {
      regions <- "exon"
      warning("No intron matrix present in tome file - using exon only")
    }
  }

  if(regions == "exon") {
    total_counts <- c(h5read(tome, "/data/total_exon_counts"))
    data <- exons / (total_counts / 1e6)
    rm(exons)
  } else if(regions == "intron") {
    total_counts <- c(h5read(tome, "/data/total_intron_counts"))
    data <- introns / (total_counts / 1e6)
    rm(introns)
  } else if(regions == "both") {
    total_counts <- c(h5read(tome, "/data/total_exon_counts")) + c(h5read(tome, "/data/total_intron_counts"))
    data      <- (exons + introns) / (total_counts / 1e6)
    rm(exons,introns)
  }

  rownames(data) <- samples
  colnames(data) <- genes

  data      <- cbind(sample_id = rownames(data),
                     as.data.frame(large_dgCMatrix_to_matrix(data)))

  print("Writing data.feather")
  feather::write_feather(data, file.path(output_folder,"data.feather"))

  data    <- flip_table(data, gene_col = "gene", sample_col = "sample_id")

  print("Writing data_t.feather")
  feather::write_feather(data, file.path(output_folder,"data_t.feather"))

  ## Read in and write the available stats
  stats <- available_tome_stats(tome)
  if(length(stats)>0){
    for(s in stats){
      stat <- read_tome_stats(tome, s)
      stat_fn <- paste0(s,".feather")
      feather::write_feather(stat, file.path(output_folder,stat_fn))
    }
  }

  ## Read in and write gene information, if available
  if(!check_tome_existence(tome,"/gene_meta/genes")){
    print("Gene info not available, and won't be written")
  } else {
    gene_info <- read_tome_gene_meta(tome)
    names(gene_info)[names(gene_info) == "gene_name"] <- "gene"  # shiny uses gene instead of gene_name
    feather::write_feather(gene_info, file.path(output_folder,"genes.feather"))
  }

  ## Read in and write projection, if available
  if (!check_tome_existence(tome, "/projection")) {
    print("TSNE not available, and won't be written")
  } else {
    tsne <- read_tome_projection(tome,projection_name)
		if(!is.element("sample_id",colnames(tsne))) tsne$sample_id <- tsne$sample_name
		tsne <- tsne[,c("sample_id","x","y")]
		colnames(tsne) <- c("sample_id",paste0(projection_name,"_x"),paste0(projection_name,"_y"))
        feather::write_feather(tsne, file.path(output_folder, "tsne.feather"))
		tsne_desc <- read_tome_projection_desc(tome)
		feather::write_feather(tsne_desc, file.path(output_folder, "tsne_desc.feather"))
  }
}


#' Returns available stats in a tome object
#'
#' @param tome the location of the tome file to read
#'
#' @return the name of available stats to read
#' @export
#'
#'
available_tome_stats <- function(tome) {
  ls <- rhdf5::h5ls(tome)
  stats_names <- ls$name[ls$group == "/stats"]
  stats_names <- stats_names[stats_names != "desc"]
  stats_names
}


